# PR Reviewer 

Микросервис для автоматического назначения ревьюверов на Pull Request'ы с управлением командами и участниками.

## Архитектура

Проект следует принципам чистой архитектуры и разделён на слои:

```
┌─────────────────┐
│   HTTP Handler  │  ← Слой представления (HTTP API)
├─────────────────┤
│    Service      │  ← Бизнес-логика
├─────────────────┤
│   Repository    │  ← Слой доступа к данным
├─────────────────┤
│   PostgreSQL    │  ← База данных
└─────────────────┘
```


## Требования

- **Go** 1.25.4 или выше
- **Docker** и **Docker Compose** для запуска окружения
- **PostgreSQL** 17.7 (запускается через Docker)
- **k6** (опционально) для нагрузочного тестирования

## Быстрый старт

### 1. Клонирование репозитория

```bash
git clone https://github.com/bagdasarian/avito-pr-reviewer.git
cd avito-pr-reviewer
```

### 2. Запуск через Docker Compose

Самый простой способ запустить весь стек:

```bash
docker-compose up
```

Эта команда автоматически:
- Запустит PostgreSQL на порту 5433
- Применит миграции базы данных
- Запустит приложение на порту 8080

Проект запускается с базовыми переменными окружения, указанными в `docker-compose.yml`:
- `POSTGRES_USER=avito`
- `POSTGRES_PASSWORD=avito`
- `POSTGRES_DB=pr_reviewer`
- `DB_HOST=postgres`
- `DB_PORT=5432`
- `DB_SSLMODE=disable`

При желании можно создать `.env` файл в корне проекта для кастомных значений, это было сделано для того, чтобы проект сразу запускался из "коробки" без ручной настройки, но для безопасности можно было выставить кастомные значения

```env
POSTGRES_USER=your_user
POSTGRES_PASSWORD=your_password
POSTGRES_DB=your_db_name
```

Docker Compose автоматически подхватит переменные из `.env` файла.


### 3. Остановка

```bash
docker-compose down
```

## Makefile команды

Проект включает Makefile с удобными командами:

```bash
make help              # Показать все доступные команды
make build             # Собрать приложение
make run               # Запустить приложение локально
make test              # Запустить unit-тесты
make test-integration  # Запустить интеграционные тесты
make test-coverage     # Запустить тесты с покрытием
make fmt               # Форматировать код
make docker-up         # Запустить docker-compose
make docker-down       # Остановить docker-compose
make load-test-low     # Нагрузочный тест (low)
make load-test-medium  # Нагрузочный тест (medium)
make load-test-high    # Нагрузочный тест (high)
make load-test-stress  # Нагрузочный тест (stress)
```

## API Документация

API соответствует OpenAPI спецификации. Все эндпоинты:

### Команды (Teams)

- `POST /team/add` — Создать команду с участниками
- `GET /team/get?team_name={name}` — Получить команду с участниками

### Пользователи (Users)

- `POST /users/setIsActive` — Установить флаг активности пользователя
- `GET /users/getReview?user_id={id}` — Получить PR'ы, где пользователь назначен ревьювером

### Pull Requests

- `POST /pullRequest/create` — Создать PR и автоматически назначить ревьюверов
- `POST /pullRequest/merge` — Пометить PR как MERGED (идемпотентная операция)
- `POST /pullRequest/reassign` — Переназначить ревьювера

### Статистика

- `GET /stats` — Получить статистику по ревьюверам и статусам PR


### Примеры запросов

Создание команды:
```bash
curl -X POST http://localhost:8080/team/add \
  -H "Content-Type: application/json" \
  -d '{
    "team_name": "backend",
    "members": [
      {"user_id": "u1", "username": "Alice", "is_active": true},
      {"user_id": "u2", "username": "Bob", "is_active": true}
    ]
  }'
```

Создание PR:
```bash
curl -X POST http://localhost:8080/pullRequest/create \
  -H "Content-Type: application/json" \
  -d '{
    "pull_request_id": "pr-1001",
    "pull_request_name": "Add search feature",
    "author_id": "u1"
  }'
```

## Тестирование

Проект включает три типа тестов:

### 1. Unit-тесты

Тесты репозиториев и сервисов с использованием моков:

```bash
make test
# или
go test ./...
```

**Покрытие:**
- Репозитории: тесты с `go-sqlmock` для проверки SQL-запросов
- Сервисы: тесты с моками репозиториев из `internal/mocks/`

### 2. Интеграционные тесты

Тесты с реальной PostgreSQL через `testcontainers-go`:

```bash
make test-integration
# или
go test -tags=integration -v ./test/integration/...
```

**Особенности:**
- Автоматический запуск PostgreSQL в Docker-контейнере
- Автоматическое применение миграций
- Изоляция: каждый тест получает чистую БД
- Автоматическая очистка после тестов

**Покрытие:**
- Создание PR с автоматическим назначением ревьюверов
- Переназначение ревьюверов
- Merge PR и блокировка изменений
- Идемпотентность merge
- Статистика

### 3. Нагрузочное тестирование

Нагрузочные тесты с использованием k6:

```bash
make load-test-low      # 5 RPS, 1 минута
make load-test-medium   # 20-50 RPS, 1 минута
make load-test-high     # 50-200 RPS, 1 минута
make load-test-stress   # 100-500 RPS, 1 минута
```

**Результаты тестирования:**

| Тест | Статус | p(95) latency | Checks rate | Errors rate | RPS |
|------|--------|--------------|-------------|-------------|-----|
| **Low** | PASSED | 5.13ms | 100.00% | 0.00% | 12.3 |
| **Medium** | PASSED | 8.85ms | 100.00% | 0.00% | 215.1 |
| **High** | PASSED | 232.92ms | 95.43% | 4.56% | 1,216.9 |
| **Stress** | FAILED | 509.58ms | 70.54% | 29.45% | 1,390.0 |

## Дополнительные задания

### Статистика

Реализован эндпоинт `GET /stats`, который возвращает:
- Статистику по ревьюверам (количество назначений на каждого пользователя)
- Статистику по статусам PR (количество PR в каждом статусе)

### Нагрузочное тестирование

Проведено нагрузочное тестирование с использованием k6. Результаты показывают, что сервис соответствует требованиям:
- **RPS:** 5 (требование выполнено)
- **SLI времени ответа:** p(95) < 300ms (выполнено для low/medium нагрузок)
- **SLI успешности:** 99.9% (выполнено для low/medium нагрузок)

### Интеграционное тестирование

Реализованы интеграционные тесты с использованием `testcontainers-go`:
- Автоматический запуск PostgreSQL в изолированных контейнерах
- Тестирование полного цикла работы с БД
- Покрытие основных сценариев использования

## Вопросы и решения

### 1. Переназначение ревьювера на уже назначенного

**Проблема:** При попытке заменить ревьювера на того, кто уже назначен на PR, возникала ошибка `duplicate key value violates unique constraint`.

**Решение:** Добавлена проверка существования нового ревьювера перед операцией. Если новый ревьювер уже назначен, выполняется DELETE старого ревьювера вместо UPDATE.

### 2. Идемпотентность merge

**Вопрос:** Как обеспечить идемпотентность операции merge?

**Решение:** Операция merge проверяет текущий статус PR. Если PR уже в статусе MERGED, операция возвращает текущее состояние без ошибки.

**Файл:** `internal/service/pullrequest_service_impl.go`


### 3. Изоляция тестов

**Вопрос:** Как обеспечить изоляцию интеграционных тестов?

**Решение:** Использован `testcontainers-go` для автоматического создания и удаления изолированных контейнеров PostgreSQL для каждого теста.

**Файл:** `test/integration/setup.go`

### 4. Организация моков

**Вопрос:** Где размещать моки для тестов?

**Решение:** Моки вынесены в отдельный пакет `internal/mocks/` для использования только в тестах

**Файл:** `internal/mocks/mocks.go`

### 6. Передача ID PR при создании

**Проблема:** Изначально в БД поле `id` таблицы `pull_requests` было типа `SERIAL`, что означало автоматическую генерацию ID со стороны базы данных. Это не позволяло передавать свой ID в body запроса при создании PR.

**Решение:** 
1. Изменён тип поля `id` с `SERIAL` на `INTEGER PRIMARY KEY`


## Производительность

- Использование индексов в БД для оптимизации запросов:
  - `idx_users_team_active` — для быстрого поиска активных пользователей команды
  - `idx_pr_reviewers_pr_id` — для быстрого поиска ревьюверов PR
  - `idx_pr_reviewers_reviewer_id` — для быстрого поиска PR по ревьюверу


